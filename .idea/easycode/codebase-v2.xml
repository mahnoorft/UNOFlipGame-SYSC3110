<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="com.obiscr.chatgpt.settings.EasyCodeState">
    <option name="projectFiles" value="$PROJECT_DIR$/src/Card.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/CardTest.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/CreatePlayersView.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/Deck.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/DeckTest.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/Hand.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/HandTest.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/Main.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/Player.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/PlayerAI.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/PlayerTest.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/UNOGameController.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/UNOGameEvent.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/UNOGameFrame.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/UNOGameHandler.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/src/UNOGameModel.java;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110/README.md" />
    <option name="forceFullIndex" value="false" />
    <option name="fileSummaryMaps" value="{&quot;C:/Users/ramaa/OneDrive/Desktop/UNOFlipGame-SYSC3110&quot;:&quot;{\&quot;/src/UNOGameFrame.java\&quot;:\&quot;This Java file defines the UNOGameFrame class, which represents the user interface and visualization of the UNO game application. It adheres to the Model-View-Controller (MVC) architectural pattern.\\n\\nKey functions:\\n\\n- Constructor - Initializes the GUI components like panels, buttons, labels etc and sets up the event listeners. Displays the initial game state.\\n\\n- displayPlayerHand() - Displays the current player\\u0027s hand of cards. \\n\\n- displayTopCard() - Displays the card on top of the draw pile.\\n\\n- winRoundScreen() - Displays the screen when a player wins a round. \\n\\n- winGameScreen() - Displays the screen when a player wins the game.\\n\\n- restartRoundScreen() - Restarts the round after it ends. \\n\\n- updateStatusBar() - Updates the status bar text.\\n\\n- drawCardDialog() - Prompts player to play a drawn card or add to hand.\\n\\n- wildDialog() - Prompts player to choose color for Wild card.\\n\\n- handleDrawCard(), handlePlayCard(), handleNextTurn(), handleCallUNO() - Event handler methods that update the GUI based on game events.\\n\\nSo in summary, it defines the GUI and handles displaying the game state and interacting with the player via buttons/dialogs to update the underlying UNOGameModel based on player actions.\&quot;,\&quot;/src/PlayerTest.java\&quot;:\&quot;This file contains unit tests for the Player class in the UNO Flip game.\\n\\nThe key things it does:\\n\\n1. Sets up a Deck and Player object before each test method runs. This is done so each test has a fresh Deck and Player to work with.\\n\\n2. Contains test methods that validate the core functionality of the Player class:\\n\\n- drawCard() - Tests drawing a card from the deck increases hand size\\n- incrementScore() - Tests score is correctly incremented \\n- getScore() - Tests initial score is 0\\n- getName() - Tests player name is retrieved correctly\\n- getHand() - Tests hand is not null\\n- playCard() - Tests playing a card removes it from hand correctly  \\n- clearHand() - Tests clearing hand empties it\\n\\n3. Each test method asserts an expected outcome to validate the Player class is working as intended.\\n\\n4. Allows thoroughly testing the Player class in isolation without relying on other game logic or classes.\\n\\nSo in summary, it sets up unit tests that validate the key functions of the Player class work as expected through assertions. This helps ensure the Player class is correctly implemented.\&quot;,\&quot;/src/PlayerAI.java\&quot;:\&quot;This PlayerAI.java file defines an AI player for the card game.\\n\\nKey points:\\n\\n- PlayerAI extends Player, so it inherits the base player functionality\\n- It has a constructor that passes the name and isBot flag to the parent Player constructor\\n\\nKey functions:\\n\\n- getBestPlay(): Loops through the player\\u0027s hand, checks which card is valid to play given the top card and turn side, and plays that card if found. Returns null if no valid card.\\n- getBestColor(): Loops through the hand to find the most common color that is not a wild card. If no color found, returns a default color based on turn side (light or dark).\\n\\nSo in summary, this defines an AI player class that can:\\n\\n- Get the best card to play given the game state \\n- Determine the best color to suggest if no valid cards can be played\\n\\nThis allows the AI player to make automated plays and suggestions during its turn.\&quot;,\&quot;/src/CreatePlayersView.java\&quot;:\&quot;This Java file defines the CreatePlayersView class which handles displaying the user interface to create and set up players for a game.\\n\\nKey functions:\\n\\n- Constructor - Displays dialogs to prompt the user to select number of human and AI players. Also calls setPlayerNamesDialog() to get player names.\\n\\n- setPlayerNamesDialog() - Displays a dialog with text fields to enter names for each human player. Validates that all names are entered before accepting.\\n\\n- getNameList() - Returns the list of names entered by the user for the human players. \\n\\n- getNumAIPlayers() - Returns the number of AI players selected by the user.\\n\\nThe main purpose of this class is to:\\n\\n1. Prompt the user to select number of players\\n2. Get player names for human players \\n3. Validate all names are entered\\n4. Return the player name list and number of AI players for use in the game.\\n\\nIt handles the user interface for setting up the players before starting the actual game.\&quot;,\&quot;/src/CardTest.java\&quot;:\&quot;This Java file contains unit tests for the Card class using JUnit.\\n\\nKey things it does:\\n\\n- Imports the JUnit testing framework \\n- Declares a CardTest class to hold the test methods\\n- Declares some Card objects to use in the tests\\n- Annotates test methods with @Test\\n- Sets up the test structure with @BeforeEach\\n\\nKey test methods:\\n\\n- testAssignPoint() - Tests that points are assigned correctly to cards \\n- testCheckValid() - Tests if a card can be played is correctly checking\\n- testIsSpecial() - Tests if a card is identified as a special card\\n- testToString() - Tests the toString() method outputs the card correctly\\n\\nSo in summary, it contains a suite of unit tests to validate the core functionality of the Card class like point assignment, valid play checking, special card identification, and string representation. The tests help ensure the Card class works as expected.\&quot;,\&quot;/src/DeckTest.java\&quot;:\&quot;This file contains unit tests for the Deck class using JUnit.\\n\\nThe key things it does:\\n\\n- Sets up a full Deck and empty Deck for testing in the @BeforeEach setup method.\\n\\n- Tests are commented out for:\\n\\n  - testCreateDeck() - Verifies the deck is initialized correctly with all expected cards\\n\\n  - testRefill() - Tests refilling the deck from a pile of cards\\n\\n  - testDraw() - Tests drawing a card decrements size and empty deck returns null\\n\\n  - testSize() - Tests getting the deck size returns correctly initially and after a draw\\n\\n- Uses JUnit assertions like assertEquals, assertNotNull to validate test outcomes.\\n\\nKey functions/methods tested:\\n\\n- Deck constructor \\n- getDeck()\\n- draw()\\n- refill() \\n- size()\\n\\nThe purpose is to validate the Deck class is working as expected by setting up sample data and scenarios to test the core functionality.\&quot;,\&quot;/src/HandTest.java\&quot;:\&quot;This file contains JUnit tests for the Hand class.\\n\\nKey things it does:\\n\\n- Defines a HandTest class that will contain the test methods\\n- Imports the JUnit testing framework \\n- Declares some Card objects that will be used in the tests\\n- Has a @BeforeEach method that initializes the Hand object before each test\\n\\nKey functions it tests:\\n\\n- testAddCard() - Tests adding cards to the hand\\n- testRemoveCard() - Tests removing a card by index \\n- testRemoveAll() - Tests clearing all cards from the hand\\n- testCalculateTotalPoints() - Tests calculating the total point value of cards\\n- testIsUNO() - Tests the isUNO() method that checks if hand has 1 card\\n- testIsEmpty() - Tests the isEmpty() method that checks if hand is empty\\n\\nSo in summary, it sets up test data and methods to validate the core functionality of the Hand class like adding/removing cards and calculating points works as expected. This allows verifying the Hand class is implemented correctly.\&quot;,\&quot;/src/Deck.java\&quot;:\&quot;This Deck.java file defines a Deck class that represents the UNO Flip game deck.\\n\\nKey functions:\\n\\n- createDeck() - Initializes the deck by adding all the standard UNO cards according to the rules. There are light side and dark side cards.\\n\\n- getDeck() - Returns the ArrayList containing all the cards in the deck. \\n\\n- shuffle() - Shuffles the cards in the deck randomly. \\n\\n- refill(List\\u003cCard\\u003e pile) - Refills the deck from the given pile and shuffles. Used when cards are drawn from the deck.\\n\\n- draw() - Removes and returns a single card from the top of the deck. \\n\\n- size() - Returns the current number of cards in the deck.\\n\\n- toString() - Returns a string representation of all the cards in the deck.\\n\\nThe Deck class manages the full set of UNO cards, handles initializing, shuffling, drawing from and refilling the deck as cards are played in the game. It encapsulates all the card data and behavior related to the game deck.\&quot;,\&quot;/src/UNOGameHandler.java\&quot;:\&quot;This file defines an interface called UNOGameHandler for handling events in a UNO card game.\\n\\nSome key points:\\n\\n- It is an interface, not a class, so it only defines function signatures and not implementations. Classes will implement this interface to handle UNO game events.\\n\\n- The functions handle different types of UNO game events like drawing a card, playing a card, next turn, calling UNO. \\n\\n- The functions all take a UNOGameEvent object as a parameter, which likely contains details about the event.\\n\\nKey functions defined in the interface:\\n\\n- handleDrawCard() - Handles when a player draws a card\\n- handlePlayCard() - Handles when a player plays a card  \\n- handleNextTurn() - Handles transition to the next player\\u0027s turn\\n- handleCallUNO() - Handles when a player calls \\\&quot;UNO\\\&quot;\\n\\nSo in summary, this interface defines the contract for classes to handle different events that occur during a UNO card game. Implementing classes will use these functions to update the game state and user interface in response to events.\&quot;,\&quot;/src/UNOGameEvent.java\&quot;:\&quot;This file defines a class called UNOGameEvent that represents an event that occurs in a UNO game. It extends the EventObject class.\\n\\nKey functions:\\n\\n- UNOGameEvent constructor that takes a UNOGameModel as a parameter - this is used to construct a basic event without a card or canPlay flag.\\n\\n- UNOGameEvent constructor that takes a UNOGameModel, Card, and Boolean canPlay flag as parameters - this fully initializes the event with all relevant data. \\n\\n- getCard() method that returns the Card associated with the event.\\n\\n- canPlay() method that returns the Boolean flag indicating if the player can play the card associated with the event.\\n\\nThis event class is used to encapsulate information about things that happen in the game, like a player playing a card, and notify listeners (likely the view) so it can update appropriately. The model would create and fire these events, and the view would register as a listener to get notified and trigger updates.\\n\\nSo in summary, it defines a reusable event object for notifying listeners of things that happen in the UNO game model with relevant data like the card and playability flag attached.\&quot;,\&quot;/src/Player.java\&quot;:\&quot;This Java file defines a Player class for an UNO card game.\\n\\nKey functions:\\n\\n- Constructor that initializes the player\\u0027s name, hand, score, and whether they are a bot or not.\\n\\n- drawCard() method that draws a card from the deck and adds it to the player\\u0027s hand. \\n\\n- incrementScore() method to update the player\\u0027s score.\\n\\n- getScore() method to get the player\\u0027s current score. \\n\\n- getName() method to get the player\\u0027s name.\\n\\n- getHand() method to get the player\\u0027s hand of cards.\\n\\n- playCard() method to play a card from the player\\u0027s hand, checking if it is valid to play against the top card. Removes the card if valid.\\n\\n- clearHand() method to remove all cards from the player\\u0027s hand. \\n\\n- isBot() method to check if the player is a bot or not.\\n\\nSo in summary, it defines the core properties and functionality of a player in the UNO card game - their name, hand of cards, score, and methods to draw/play cards, update score, and check if they are a bot player.\&quot;,\&quot;/src/Card.java\&quot;:\&quot;This file defines a Card class to represent playing cards in an UNO Flip game.\\n\\nKey functions:\\n\\n- Constructor to initialize the card with ranks and colors for both sides\\n- assignPointsLight() method to assign point values based on the light side rank\\n- checkValid() method to check if a card can be played on another card based on UNO rules\\n- getColor(), getRank() methods to get the color/rank of a specific side\\n- setColorLight/Dark() methods to set the color of a side\\n- getPoints() method to get the point value \\n- isSpecial() method to check if the card is a special card \\n- toString() methods to get string representations of the card\\n- equals() method to check equality between two Card objects\\n\\nThe main purpose of this class is to encapsulate the data and behavior of a single playing card in the UNO Flip game. It stores the ranks, colors and point values of both sides, and provides methods to check card validity, get attributes, set attributes and compare cards.\&quot;,\&quot;/src/UNOGameController.java\&quot;:\&quot;This file defines the UNOGameController class which acts as the controller in an MVC architecture for a UNO game.\\n\\nKey functions:\\n\\n- Constructor that takes in the UNOGameModel and UNOGameFrame to link the controller to the model and view.\\n\\n- actionPerformed method - This is the main method that handles GUI button click events. It parses the action command and calls the appropriate method on the model:\\n\\n  - draw - Calls model\\u0027s actionDrawCard()\\n  - end - Calls model\\u0027s actionEndTurn() \\n  - call - Calls view\\u0027s handleCallUNO() method to display UNO prompt\\n  - new - Resets the game by calling model\\u0027s initializeGame() and view\\u0027s restartRoundScreen()\\n  - newGame - Starts a new game by disposing current view and creating new model and view\\n\\n- It also parses number commands and calls model\\u0027s actionPlayCard() method.\\n\\nSo in summary, it acts as the bridge between the GUI view events and methods on the underlying game model. It processes GUI input and triggers the appropriate model changes and view updates. This allows keeping the view and model separate and testable.\&quot;,\&quot;/src/Main.java\&quot;:\&quot;This Java file is the main entry point for an UNO card game application.\\n\\nIt does the following:\\n\\n1. Creates an instance of the UNOGameModel class. This class would model the game state, rules, cards etc. \\n\\n2. Creates an instance of the UNOGameFrame class, passing in the game model. This is likely the main GUI window for the game.\\n\\n3. The UNOGameFrame class would be responsible for displaying the game state to the user and handling user input/actions like playing cards.\\n\\n4. The main() method simply initializes the game model and frame - it bootstraps the application.\\n\\nKey functions:\\n\\n- UNOGameModel - Models the game state and rules \\n- UNOGameFrame - Provides the GUI and handles user input\\n- main() - Entry point that initializes the model and GUI frame\\n\\nSo in summary, it sets up the core model and view classes needed to run the UNO card game, separating the game logic from the GUI presentation. The model is initialized first before passing to the frame to display.\&quot;,\&quot;/src/UNOGameModel.java\&quot;:\&quot;This file defines the UNOGameModel class which represents the model for a UNO card game. \\n\\nKey functions:\\n\\n- constructor - initializes the game model with empty player list, deck, pile etc.\\n\\n- createPlayers() - initializes player names and adds human/AI players to the player list\\n\\n- initializeGame() - distributes cards to players and draws first card \\n\\n- getNextPlayerIndex() - returns index of next player based on turn direction\\n\\n- executeSpecialFunction() - handles special card functions like skip, reverse etc\\n\\n- calculateWinnerScore() - calculates score for winner of current round \\n\\n- actionPlayCard() - handles playing a card from current player\\u0027s hand\\n\\n- actionDrawCard() - handles drawing a card \\n\\n- actionEndTurn() - ends current player\\u0027s turn and advances to next player\\n\\n- botPlayCard() - logic for AI player to play a card or draw\\n\\n- applyCallPenalty() - applies penalty if player didn\\u0027t call UNO\\n\\n- chooseNewColor() - handles choosing new color when wild card is played\\n\\nSo in summary, it manages the game state, rules and turns by initializing the game, tracking players/cards/pile, handling player actions and updating the model accordingly.\&quot;,\&quot;/README.md\&quot;:\&quot;This README.md file provides documentation and instructions for the UNOFlipGame project.\\n\\nKey functions of the README.md file:\\n\\n- Installation instructions - Provides commands to clone the project repository and install any necessary libraries.\\n\\n- Usage instructions - Explains how to run the UNOFlipGame application and describes the basic gameplay.\\n\\n- Feature overview - Highlights the main features of the UNOFlipGame, including support for UNO Flip rules, multiplayer gameplay, and traditional UNO rules. \\n\\n- Milestone 2 changes - Summarizes the key changes and improvements implemented in Milestone 2, such as the GUI, MVC architecture, and observer pattern.\\n\\n- Future deliverables - Outlines planned additional features and enhancements for Milestones 3 and 4, like UNO Flip card integration, AI players, redo/undo, replay, and save/load.\\n\\n- Author/contributors - Lists the main author and contributors to the project.\\n\\nIn summary, the README provides new users with the necessary information to set up and use the UNOFlipGame application, understand its features and design, and see the development roadmap for future versions. It serves as the main documentation and starting point for understanding the project.\&quot;,\&quot;/src/Hand.java\&quot;:\&quot;This Java file defines a Hand class that represents the cards in an UNO player\\u0027s hand.\\n\\nKey functions:\\n\\n- Constructor - Creates a new empty Hand\\n- addCard() - Adds a card to the hand \\n- removeCard() - Removes a card from the hand by index\\n- removeAll() - Clears all cards from the hand\\n- calculateTotalPoints() - Calculates the total point value of all cards in the hand\\n- getCards() - Gets the ArrayList of Card objects in the hand\\n- isUNO() - Checks if there is only 1 card left in the hand\\n- isEmpty() - Checks if there are no cards in the hand  \\n- toString() - Returns a string representation of the cards in the hand\\n\\nSo in summary, it models a player\\u0027s hand in the UNO card game by storing the cards as an ArrayList and providing functions to manipulate and query the hand, like adding/removing cards, calculating points, checking for UNO/empty conditions, and string representation.\&quot;}&quot;}" />
  </component>
</project>